---
title: "base r learning note"
author: "JIASHU MIAO"
date: "2019/2/4"
output: html_document
---
```{r}
library("dplyr")
library("readxl")
```
```{r}
?mean # help of function 
str(iris)
class(iris)
typeof(iris)
par(mfrow=c(2,2))
data(mtcars)
x <- c(2,4,6,8,10,NA)
seq(2,3,by = 0.1)
rep(1:2, times=3)
rep(1:2,each=3)
sort(x,decreasing = TRUE)
table(x)
unique(x)
rev(x)
mean(x, na.rm = F)
x <- na.omit(x)
```
```{r}
x
x[4]
x[-c(1,2)]
x[-(2:4)]

 #x[‘apple’]
# element with name apple

 
# for and while , if else loop

for (i in 1:4){
   j <- i + 10
print(j)
 }
```

```{r}
while (i<5 & i > 0 ) {
  
  i= i+25
  print(i)
}
i
# 没搞明白

```
```{r}
i= 1
if (i >3){
  print("yes")
} else {
  print("no")}

# global environment



square <- function(x){
  x <- 8
  square <- x*x
  return(square)
  e
}
print(square()) # 这时候 square变成了一个function 括号里面可以添加参数

```
```{r}
#read.table() read.csv 
mydat <- read_xlsx("/Users/MichaelMiao/Documents/GitHub/R-scripts-/Acumen_Data_Analysis_Exercise.xlsx",sheet = "Data")


# as.logical()
# as.array()
# as.factor()
# as.character()
# as.numeric()

x <- c(2,4,6,8,10,12)
y <- x +c(1,2)
y
log(x)
exp(x)
max(x)
min(x)
round(x,5)
sign(x)
cor(x,y)
sum(x)
mean(x)
median(x)
quantile(x)
var(x)
sd(x)
rank(x)
summary(lm(y~x))

```

```{r}
#ls()
#rm(x)
# rm(list = ls())

mat1 <- matrix(1:9,nrow = 3,byrow = F)
mat1
mat2 <- matrix(1:9,nrow = 3,byrow = T)
mat2
# print(c(mat1,mat2)) 是不对的
mat1 * mat2
mat1 %*% mat2
#solve(mat1,mat2) how to use solve func. 
```
```{r}
l <- list(x=1:5,y=c("a","b"))
l[[2]]
l[1]
l[[2]][2]
l['y']



```

```{r}

df <- data.frame(x=1:3,y=letters[1:3]) # 牛逼
df
nrow(df) #ncol, dim, cbind, rbind

```
```{r}
#strings 
paste(x,y,sep = "")
paste(x,collapse = "")
grepl(x,x) # find the patter in the expression 
grep(x,x)
#  look at the grep function and the grelp function

# repalce the matcheds in x with a string
# gsub(pattern,replace, x)
# toupper / tolower 大写小切换

nchar(x)
x
# 12 有俩characters

cut(x,breaks = 4 ) #Turn a numeric vector into a factor by ‘cutting’ into sections. ????????


# check ggplot2 and lubridate package

x <- 10
if(x > 0)
{
print("This is Positive number")
}

```

```{r}
x <- 10
if(x > 0)
{
print("This is Positive number")
}

```

```{r}
# statement function 
x <- -10
if(x >= 0)
{
print("This is Non-negative number")
} else {
print("This is Negative number")
}

```

note for stats 140sl 

ca take the exam anywhere 
no json file 
probably not spss/stata
prob excel / Rdata
there is a bunch of dataset at kaggle 
for example the gradudate admission datasets (should not be a probably in after 101c)
also review the stats knowledge for modelling, validation etc. traning
review the code in 101c
archive.ics.uci.eud/ml/datasets.html
reviw about the ggplot2 
trunc() function

```{r}
library(haven)
library(dplyr)
#summarise_all(mydata,funs(n(),mean(.,na.rm = T)))
# drop is not as mean or median 
mydata
summarise_all(mydata,funs(median))
#head(mydata$vs)
# sample_frac(): Randomly select a fraction of rows
dd <- c(1.5,1.6,1.8)
# dd
# dd <- trunc(dd)
# 不懂区别
#dd <- floor(dd)
# dd <- ceiling(dd)
# dd trunc 总是去 0


```
```{r}
x <- 5
if (x < 0) 
{
 print("This is Negative number")
} else if (x > 0) {
print("This is Positive number")
} else {
print("This is Zero")
}

for(i in 1:5)
{
for(j in 1:2)
{
print(i*j);
}
}
# R for loop with break statement
 

x <- 1:5
for (i in x) {
    if (i == 3){
        break
    }
    print(i)
}
i <- 1
while (i <=6) {
print(i*i)
i = i+1
}

```
```{r}
# Syntax for Replicate Function in R:
# 
# rep(value,number_of_times)
# rep(sequence,each,number_of_times)

rep(3:4, time = 3
    )
rep(3:4, each = 3)

```
```{r}
sapply(mydata,mode)


# Create two lists.
list1 <- list(1,2,3)
list2 <- list("Jan","Feb","Mar")
 
# Merge the two lists.
merged.list <- c(list1,list2)
 
# Print the merged list.
print(merged.list)

merged.list[[2]][1]

```
```{r}
df1 = data.frame(CustomerId = c(1:6), Product = c(rep("Oven", 3), rep("Television", 3)))
df1
# data frame 2
df2 = data.frame(CustomerId = c(2, 4, 6), State = c(rep("California", 2), rep("Texas", 1)))
df2
df<-merge(x=df1,y=df2,by="CustomerId")
df<-merge(x=df1,y=df2,by="CustomerId",all=TRUE)
df<-merge(x=df1,y=df2,by="CustomerId",all.x=TRUE)
df<-merge(x=df1,y=df2,by="CustomerId",all.y=TRUE)
df <- merge(df1,df2,by = "CustomerId", all.x = T)

# Cross join in R: A Cross Join (also sometimes known as a Cartesian Join) results in every row of one table being joined to every row of another table


df<-merge(x = df1, y = df2, by = NULL)

```
```{r}
# with function in R
 df <- data.frame(a=1:5,b=2:6)
 df
 df$c<-with(df, c <- a + b)
 df
 
 # within function in R
 
within(df, {c <- a + b; df;} ) ##花括号干嘛的
```
```{r}
# Generate sequence from 0 to 20 with length.out=5 with R seq function
 
seq(from=0, to=20, length.out=5)


```


# apply function 

```{r}

```











