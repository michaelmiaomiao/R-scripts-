---
title: "Untitled"
author: "JIASHU MIAO"
date: "2/8/2019"
output: html_document
---
-Atomic Vector: homogenous 

cdil

NaN
Inf  都是double


type of NULL IS

[1] "NULL"
typeof(NULL)

- NULL + F

integer(0)

3:6 * 3:8
longer object length is not a multiple of shorter object length[1]  9 16 25 36 21 32

3:6 * 3:4 #no waring 
[1]  9 16 15 24

•	Typeof(x= c(L=1,M=2,N=3)) is double 
•	Str(attributes(x) is a list of one 
•	Typeof(x= c(L=1,M=2,N=3)) is double 
•	Str(attributes(x) is a list of one 

attr(s,"names") <- letters[1:3]

attr(s,"names") 
[1] "a" "b" "c" NA 



attributes(s)
$names
[1] "a" "b" "c" NA 

s
  a    b    c <NA> 
   1    2    3    4  # 不循环
   
   attr(s,"something") <- "something"
s
attributes(s)
s
 a    b    c <NA> 
   1    2    3    4 
attr(,"something")
[1] "something"

•	Names(x) dim(x) class(x) won’t get lost

o	X <- c(a=1, b=2, c=3) 
o	Names(x) <- c(“a”,”b”,”c”)
o	Y <- setNames(x, c(…))

names() return NULL if ALL MISSING!S
s

sex_char
sex_factor
table(sex_factor)
sex_factor
m f 
3 0  # table 不需要括号

•	factors are actually integer vector
typeof(sex_factor)
"integer"

•	use stringAsFacotrs = FALSE to suppress forming factors 
•	gsub or grepl will coerce factor into strings 
•	nchar will throw an error and c() will use the underlying integer value

typeof(sex_factor)
c(sex_factor)
[1] 1 1 1

•	for dataframe colnames() is the same as names()
•	a dataframe is stored as a list
o	typeof(df) = “list”
o	classof(df) = “data.frame”


•	cbind() two vectors won’t work
•	tbf_df is similar as data.frame
•	real numbers are truncated to integer x[c(2.1,2.9)]

s[1.4]
a 
1 
# real number are truncted into interger

•	logical vector select TRUE values
o	if shorter, will recycle
o	missing value yields a missing value too
•	nothing returns the original vector
•	array is column major order so you can 	subset them with a single vector 

class(df)
d1 <- df[,1, drop = F]
d1
can still keep the data.frame



DTM[[1]][1]
[1] 1
VECTOR 进入内部


DTM[1][1]
$i
  [1]  1  1  1  1  1  1  2  2  2  2  2  2  2  2  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3  3
 [32]  4  4  4  4  4  4  4  4  4  4  5  5  5  5  5  5  5  5  5  5  5  5  5  5  5  6  6  6  6  6  6
 [63]  6  6  6  6  6  6  6  6  6  6  6  6  6  7  7  7  7  7  7  7  7  7  8  8  8  8  8  8  8  8  8
 [94]  8  8  8  8  8  8
 
 
 lapply(mtcars,as.integer) #keeps tpye
 
 •	Remove a column by set it to NULL
•	Setdiff(x, y) returns things in x but not y


•	x[!y] is not equal to x[-which(y)]   
o	if all y values are false, which(y) will be integer(0)



•	&& || only evaluate first vector 
•	Xor(x,y) is true when only one of them is true

isTRUE(s)  logical lenth one

•	1:length(l) = seq_along(l) = seq_len(length(l))

•	If we want a function to return multiple values, has to group them together
•	Can use argument names to enter arguments in a different order
o	Can give default values too
•	R does scoping (if can’t find a variable in the function body’ scope, will look for it in the next higher scope and so on
•	The enclosing environment is where function is created( only 1 enclosing environment) 

•	Calling a function creates an ephemeral execution 
o	Associated with a a calling environment
•	R’s scoping rules will use the enclosing environment, looks in the enclosing environment
•	R also supports dynamic scoping (look values in the calling environment)
•	A class defines the behavior of objects by describing their attributes and their relationship to other classes
o	Organized in a hierarchy
•	If a method does not exist for a child, use the parent’s method

!!!!
•	Methods are functions that behave differently depending on the class of their input 


•	Reference classes implements message-passing OO, so methods belong to classes, not functions
o	Mutable: they don’t use R’s usual copy-on-modify semantics
•	The type of a function is “closure”
•	The type of a primitive function is “builtin”
•	Is.object(x) returns FALSE if it’s a base type



##  ## ##  ###
s.object(x) & !isS4(x)
o	Pryr::otype()   
o	Df and factor are S3
o	Methods belong to functions called generic functions
o	Ftype() which describes the object system
o	S3 has no check so you can change the class of existing objects
o	Inherits(x, “classname”)
o	 F <- function(x) UseMethod(“f”)
•	F.a <- function(x) “Class a”

###
•	Wrangling data
o	Gather(df, key column,  name of the new value column, indexes of column to collapse)
o	Spread(df, key column, value column)
o	Arrange()  normally goes from low to high but can change it as desc




```{r}
 
```
```{r}

text = c('Peter','Piper picked a peck of Pickled peppers')

str_extract_all(text,"[Pp]\\w*?") #ungreedy
str_extract_all(text,"[Pp]\\w*")
```
```{r}

```






```{r}
library(tidyr)
case1 <- data.frame(country=c("FR","DE"),year=list("2011"=c(7000,5800),"2012"=c(6900,6000),"2013"=c(7000,6200)))
case1
gather(case1,"year","n",2:4)
gather(case1,"year","n",3:4)
# install.packages("devtools")

# devtools::install_github("rstudio/EDAWR")
```
```{r}
library(EDAWR)

cases1 <- cases[c(1,2),] %>% print()
gather(cases1,"year","n",3:4)

# 2:4 is the range (columns) of the data we are grabbing to use as the content of the table. If we grabbed 3:4, then the second column is treated as another variable, so the fourth column of the table would be 2011 and then recycling the two data 7000 and 5800 until the entire table is full.
```

```{r}
library(stringr)
greedy_pattern <- "[Aa]\\w*a" 
ungreedy_pattern <- "[Aa]\\w*?a"
string <- c("Alabama, Alaska, California") 
str_extract_all(string, greedy_pattern)
str_extract_all(string, ungreedy_pattern)
```

```{r}
df <- data.frame(
  x=1:3,
  y=c("a","b","c"),
  z=c(TRUE,FALSE,FALSE)
)
df[[1]]
```
```{r}
 f <- function(y) {
   y <<- y + 1
  2*x
  }
 x <- 3
 y <- 5 
 f(x)

y
# [1] 6
# [1] 4
```
```{r}
a <- 4:1 
a + 3:5

# longer object length is not a multiple of shorter object lengh[1] 7 7 7 4
```
```{r}
junk <- list(c(TRUE, "FALSE"), c(FALSE, TRUE)) 
typeof(junk[1])
class(junk[1])
 junk[[1]][1] %>% typeof()  #"character"
 
 junk[[1]][1]
# [1] "TRUE" (已经被教训coerce成cha) 
```

```{r}
x <- list(-5, 3L, FALSE, NA, NULL, NaN, Inf, 0/0)
 for(i in x){
print(typeof(i)) 
 }
typeof(NaN)# [1] "double"
x # 不同的list 可以保持不同的type
# NA is logical
```
```{r}

```






